events!

model

view

view-model

webcomponents

all data bindings in markup




события

повторное использование:
- кода
- шаблонов

сценарии:
1. ОС на js
Одно глобальное приложение. Много запускаемых приложений. Каждое приложение состоит из нескольких модулей.

2. Простое/сложное приложение
Приложение глобально. Оно состоит из одного/нескольких модулей.

3. Встраиваемый вариант
Один модуль.

Архитектура
Дерево модулей

Каждый модуль - атомарная, изолированная внутри единица приложения.
Модуль пробрасывает события своих компонентов, предоставляет методы для управления ими извне.
Модуль нужен для снижения сложности за счет:
- предоставления высокоуровневого интерфейса выполнения операций
- инкапсуляции взаимодействия своих компонентов
- повторного использования

В связи с этим, модуль - достаточно крупная единица.



Состав модуля:
1. Представления (Views). Представление - это атомарное по сути отражение данных в элемент веб-страницы.
Представление может быть:
- Атомарным. Атомарное представление не содержит мест для вставки других представлений
- Контейнером. Контейнер содержит именованный список позиций для вставки
 - Список
 В список вставляется
 - Шаблон
Представление состоит из:
- шаблона, преобразованного в динамически изменяемый DOM-элемент
- набора данных, непосредственно отраженных в DOM-элементе (двухсторонняя связь между набором данных и DOM):
  Например:
   - массив <-> нумерованный(ol)/ненумерованный список(ul)
   -
-

Типы отображаемых данных:
 - примитивы (число/строка/boolean и т.д.)
 -


DOM <= direct double-side data-binding => View
View <= compex data-binding via ViewModel => Model

Сценарии использования представления:
- Отображение статики.
Отображение данных. Взаимодействия нет. Изменений DOM нет
Пример: текст

- Отображение статики со взаимодействием.
Отображение данных. Взаимодействие есть. Изменений DOM нет.
Для взаимодействия нужно добавлять обработчики событий на элементы DOM. Для этого нужен инcтрумент выборки узлов дерева (querySelector)
Пример: Ссылка
Взаимодействие: клик, наведение мыши

- Отображение изменяемого контента. Простой вариант - без взаимодействия, без изменения структуры DOM
Пример: Поле ввода
Изменение: Значение поля ввода, добавление, удаление, изменение атрибутов

- Отображение изменяемого контента. Сложный вариант - без взаимодействия, с изменением структуры DOM
Изменение структуры DOM ограничивается вставкой/заменой/удалением представлений в указанные места шаблона.
В 1 место может быть вставлено несколько представлений.

Места шаблона именуются. Ограничение выборки через querySelector - выборка только в пределах шаблона.
Элементы, попадающие в дочерние представления в выборку не попадают. (Как это сделать?)

Пример: Таблица. 3 места - шапка, тело, пагинация
Состав представления:
- Шаблон. В шаблоне указываются места, в которые производится вставка элементов. Здесь простейшая шаблонизация:
  В строку шаблона вставляются переменные вида {{name}}, указывающие на места вставки элементов. После рендеринга эти элементы
  должны быть текстовыми элементами (не атрибутами). Вычисляется положение этих элемементов, а сами элементы - удаляются
- Селекторы событий. Применяются после рендеринга шаблона
- В представлении вручную задаются атрибуты, которые через события DOM получают измененные данные, а через методы доступа - изменяют их
- Переменные, в которые заносятся места - определяются вручную

2. Модель (Model) и хранилище (Store)
Представление связывается непосредственно с указанной моделью
С чем работаем:
- структура данных
- сами данные
- модели (в хранилище)
- прокси - объект, осуществляющий синхронизацию с бэкендом. Состоит из читателя и писателя
- отношения: one-one, one-many, many-many
- правила валидации

Провайдеры данных:
- localStorage
- sessionStorage
- cookies
- indexedDB (возможно, WebSQL, если indexedDB не поддерживается)
- XMLHttpRequest
- WebSockets
- возможно, что-то еще
